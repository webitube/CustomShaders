// Switches
uniform bool passthrough = false;
uniform bool showCenter = false;

//                    MIN    MAX  STEP
#pragma cropLeft      0.0,   1.0, 0.01
#pragma cropRight     0.0,   1.0, 0.01
#pragma cropTop       0.0,   1.0, 0.01
#pragma cropBottom    0.0,   1.0, 0.01
#pragma rotation   -180.0, 180.0, 0.01
#pragma zoom         -1.0,   1.0, 0.01
#pragma offsetX      -1.0,   1.0, 0.01
#pragma offsetY      -1.0,   1.0, 0.01

#pragma stepRadius     0.0,  8.0, 0.01
#pragma stdDev         0.0,  4.0, 0.01
#pragma sharpness      0.0,  1.0, 0.01
#pragma contrast       0.0,  1.0, 0.01
#pragma avgLuminance   0.0,  1.0, 0.01
#pragma edgeScale      1.0,  10.0, 0.01
#pragma edgePower      1.0,  10.0, 0.01

#pragma midGammaScale      0.0, 8.0, 0.01
#pragma midBrightnessScale 0.0, 8.0, 0.01
#pragma midSaturationScale      0.0, 2.0, 0.01

#pragma finalGammaScale      0.0, 8.0, 0.01
#pragma finalBrightnessScale 0.0, 8.0, 0.01
#pragma finalSaturationScale 0.0, 2.0, 0.01

#pragma shadowLuminance      0.0, 1.0, 0.01
#pragma shadowBlend          0.0, 0.25, 0.01
#pragma highlightLuminance   0.0, 1.0, 0.01
#pragma highlightBlend       0.0, 0.25, 0.01

#pragma colorTemperatureK     3500.0, 8000.0, 1.0
#pragma colorTemperatureAlpha 0.0, 1.0, 0.01
#pragma colorRed              0.0, 2.0, 0.01
#pragma colorGreen            0.0, 2.0, 0.01
#pragma colorBlue             0.0, 2.0, 0.01

uniform float cropLeft   = 0.0;
uniform float cropRight  = 0.0;
uniform float cropTop    = 0.0;
uniform float cropBottom = 0.0;
uniform float rotation   = 0.0;
uniform float zoom       = 0.0;
uniform float offsetX    = 0.0;
uniform float offsetY    = 0.0;

uniform bool showBlur = false;
uniform float stepRadius = 0.0;
uniform float stdDev = 0.0;
uniform float sharpness = 0.0;

uniform float contrast = 0.0;
uniform float avgLuminance = 0.0f;

uniform bool showEdge = false;
uniform float edgeScale = 1.0;
uniform float edgePower = 1.0;

uniform bool showLowLuminance = false;
uniform float shadowLuminance = 0.0;
uniform float shadowBlend = 0.05;
uniform bool showHighLuminance = false;
uniform float highlightLuminance = 1.0;
uniform float highlightBlend = 0.05;
uniform bool showMiddleLuminance = false;

uniform float colorTemperatureK = 6500.0;
uniform float colorTemperatureAlpha = 1.0;
uniform float colorRed = 1.0;
uniform float colorGreen = 1.0;
uniform float colorBlue = 1.0;

uniform float midGammaScale = 1.0;
uniform float midBrightnessScale = 1.0;
uniform float midSaturationScale = 1.0;

uniform float finalGammaScale = 1.0;
uniform float finalBrightnessScale = 1.0;
uniform float finalSaturationScale = 1.0;


//uniform texture2d background = "wood.png";

// https://www.google.com/search?q=light+bulb+color+temperature+chart&rlz=1C1GCEA_enUS983US983&oq=light+bulb+color+tem&aqs=chrome.1.0i512l2j69i57j0i512l7.4615j0j1&sourceid=chrome&ie=UTF-8#imgrc=IXp8bEporMi6tM
// source: https://www.shadertoy.com/view/lsSXW1
float3 ColorTemperatureToRGB(float temperatureInKelvins)
{
   float3 retColor;
   
    temperatureInKelvins = clamp(temperatureInKelvins, 1000.0, 40000.0) / 100.0;
    
    if (temperatureInKelvins <= 66.0)
    {
        retColor.r = 1.0;
        retColor.g = saturate(0.39008157876901960784 * log(temperatureInKelvins) - 0.63184144378862745098);
    }
    else
    {
      float t = temperatureInKelvins - 60.0;
        retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));
        retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));
    }
    
    if (temperatureInKelvins >= 66.0)
        retColor.b = 1.0;
    else if(temperatureInKelvins <= 19.0)
        retColor.b = 0.0;
    else
        retColor.b = saturate(0.54320678911019607843 * log(temperatureInKelvins - 10.0) - 1.19625408914);

    return retColor;
}


// source: https://www.ryanjuckett.com/photoshop-blend-modes-in-hlsl/
//******************************************************************************
// Looks at each channel’s color information and multiplies the inverse of the
// blend and base colors.
//******************************************************************************
float3 BlendMode_Screen3(float3 base, float3 blend)
{
   return base + blend - base*blend;
}

//******************************************************************************
// Darkens or lightens the colors, depending on the blend color. 
//******************************************************************************
float BlendMode_SoftLight(float base, float blend)
{
   if (blend <= 0.5)
   {
      return base - (1-2*blend)*base*(1-base);
   }
   else
   {
      float d = (base <= 0.25) ? ((16*base-12)*base+4)*base : sqrt(base);
      return base + (2*blend-1)*(d-base);
   }
}

float3 BlendMode_SoftLight3(float3 base, float3 blend)
{
   return float3(  BlendMode_SoftLight(base.r, blend.r), 
               BlendMode_SoftLight(base.g, blend.g), 
               BlendMode_SoftLight(base.b, blend.b) );
}

//******************************************************************************
// Selects the blend color, ignoring the base.
//******************************************************************************
float3 BlendMode_Normal3(float3 base, float3 blend)
{
   return blend;
}

//******************************************************************************
// Looks at the color information in each channel and selects the base or blend 
// color—whichever is darker—as the result color.
//******************************************************************************
float3 BlendMode_Darken3(float3 base, float3 blend)
{
   return min(base, blend);
}

//******************************************************************************
// Looks at the color information in each channel and multiplies the base color
// by the blend color.
//******************************************************************************
float3 BlendMode_Multiply3(float3 base, float3 blend)
{
   return base*blend;
}

//******************************************************************************
// Looks at the color information in each channel and darkens the base color to 
// reflect the blend color by increasing the contrast between the two.
//******************************************************************************
float BlendMode_ColorBurn(float base, float blend)
{
    if (base >= 1.0)
        return 1.0;
    else if (blend <= 0.0)
        return 0.0;
    else    
      return 1.0 - min(1.0, (1.0-base) / blend);
}

float3 BlendMode_ColorBurn3(float3 base, float3 blend)
{
   return float3(  BlendMode_ColorBurn(base.r, blend.r), 
               BlendMode_ColorBurn(base.g, blend.g), 
               BlendMode_ColorBurn(base.b, blend.b) );
}

//******************************************************************************
// Looks at the color information in each channel and darkens the base color to 
// reflect the blend color by decreasing the brightness.
//******************************************************************************
float BlendMode_LinearBurn(float base, float blend)
{
   return max(0, base + blend - 1);
}

float3 BlendMode_LinearBurn3(float3 base, float3 blend)
{
   return float3(  BlendMode_LinearBurn(base.r, blend.r), 
               BlendMode_LinearBurn(base.g, blend.g), 
               BlendMode_LinearBurn(base.b, blend.b) );
}

//******************************************************************************
// Looks at the color information in each channel and selects the base or blend 
// color—whichever is lighter—as the result color.
//******************************************************************************
float3 BlendMode_Lighten(float3 base, float3 blend)
{
   return max(base, blend);
}

//******************************************************************************
// Looks at each channel’s color information and multiplies the inverse of the
// blend and base colors.
//******************************************************************************
float3 BlendMode_Screen3(float3 base, float3 blend)
{
   return base + blend - base*blend;
}

//******************************************************************************
// Looks at the color information in each channel and brightens the base color 
// to reflect the blend color by decreasing contrast between the two. 
//******************************************************************************
float BlendMode_ColorDodge(float base, float blend)
{
   if (base <= 0.0)
      return 0.0;
   if (blend >= 1.0)
      return 1.0;
   else
      return min(1.0, base / (1.0-blend));
}

float3 BlendMode_ColorDodge3(float3 base, float3 blend)
{
   return float3(  BlendMode_ColorDodge(base.r, blend.r), 
               BlendMode_ColorDodge(base.g, blend.g), 
               BlendMode_ColorDodge(base.b, blend.b) );
}

//******************************************************************************
// Looks at the color information in each channel and brightens the base color 
// to reflect the blend color by decreasing contrast between the two. 
//******************************************************************************
float BlendMode_LinearDodge(float base, float blend)
{
   return min(1, base + blend);
}

float3 BlendMode_LinearDodge3(float3 base, float3 blend)
{
   return float3(  BlendMode_LinearDodge(base.r, blend.r), 
               BlendMode_LinearDodge(base.g, blend.g), 
               BlendMode_LinearDodge(base.b, blend.b) );
}

//******************************************************************************
// Multiplies or screens the colors, depending on the base color. 
//******************************************************************************
float BlendMode_Overlay(float base, float blend)
{
   return (base <= 0.5) ? 2*base*blend : 1 - 2*(1-base)*(1-blend);
}

float3 BlendMode_Overlay3(float3 base, float3 blend)
{
   return float3(  BlendMode_Overlay(base.r, blend.r), 
               BlendMode_Overlay(base.g, blend.g), 
               BlendMode_Overlay(base.b, blend.b) );
}

//******************************************************************************
// Multiplies or screens the colors, depending on the blend color.
//******************************************************************************
float BlendMode_HardLight(float base, float blend)
{
   return (blend <= 0.5) ? 2*base*blend : 1 - 2*(1-base)*(1-blend);
}

float3 BlendMode_HardLight3(float3 base, float3 blend)
{
   return float3(  BlendMode_HardLight(base.r, blend.r), 
               BlendMode_HardLight(base.g, blend.g), 
               BlendMode_HardLight(base.b, blend.b) );
}

//******************************************************************************
// Burns or dodges the colors by increasing or decreasing the contrast, 
// depending on the blend color. 
//******************************************************************************
float BlendMode_VividLight(float base, float blend)
{
   return (blend <= 0.5) ? BlendMode_ColorBurn(base,2*blend) : BlendMode_ColorDodge(base,2*(blend-0.5));
}

float3 BlendMode_VividLight3(float3 base, float3 blend)
{
   return float3(  BlendMode_VividLight(base.r, blend.r), 
               BlendMode_VividLight(base.g, blend.g), 
               BlendMode_VividLight(base.b, blend.b) );
}

//******************************************************************************
// Burns or dodges the colors by decreasing or increasing the brightness, 
// depending on the blend color.
//******************************************************************************
float BlendMode_LinearLight(float base, float blend)
{
   return (blend <= 0.5) ? BlendMode_LinearBurn(base,2*blend) : BlendMode_LinearDodge(base,2*(blend-0.5));
}

float3 BlendMode_LinearLight3(float3 base, float3 blend)
{
   return float3(  BlendMode_LinearLight(base.r, blend.r), 
               BlendMode_LinearLight(base.g, blend.g), 
               BlendMode_LinearLight(base.b, blend.b) );
}

//******************************************************************************
// Replaces the colors, depending on the blend color.
//******************************************************************************
float BlendMode_PinLight(float base, float blend)
{
   return (blend <= 0.5) ? min(base,2*blend) : max(base,2*(blend-0.5));
}

float3 BlendMode_PinLight3(float3 base, float3 blend)
{
   return float3(  BlendMode_PinLight(base.r, blend.r), 
               BlendMode_PinLight(base.g, blend.g), 
               BlendMode_PinLight(base.b, blend.b) );
}

//******************************************************************************
// Adds the red, green and blue channel values of the blend color to the RGB 
// values of the base color. If the resulting sum for a channel is 255 or 
// greater, it receives a value of 255; if less than 255, a value of 0.
//******************************************************************************
float BlendMode_HardMix(float base, float blend)
{
   return (base + blend >= 1.0) ? 1.0 : 0.0;
}

float3 BlendMode_HardMix3(float3 base, float3 blend)
{
   return float3(  BlendMode_HardMix(base.r, blend.r), 
               BlendMode_HardMix(base.g, blend.g), 
               BlendMode_HardMix(base.b, blend.b) );
}

//******************************************************************************
// Looks at the color information in each channel and subtracts either the 
// blend color from the base color or the base color from the blend color, 
// depending on which has the greater brightness value. 
//******************************************************************************
float3 BlendMode_Difference(float3 base, float3 blend)
{
   return abs(base-blend);
}

//******************************************************************************
// Creates an effect similar to but lower in contrast than the Difference mode.
//******************************************************************************
float3 BlendMode_Exclusion(float3 base, float3 blend)
{
   return base + blend - 2*base*blend;
}

//******************************************************************************
// Looks at the color information in each channel and subtracts the blend color 
// from the base color.
//******************************************************************************
float3 BlendMode_Subtract(float3 base, float3 blend)
{
   return max(0, base - blend);
}

//******************************************************************************
// Looks at the color information in each channel and divides the blend color 
// from the base color.
//******************************************************************************
float BlendMode_Divide(float base, float blend)
{
   return blend > 0 ? min(1, base / blend) : 1;
}

float3 BlendMode_Divide3(float3 base, float3 blend)
{
   return float3(  BlendMode_Divide(base.r, blend.r), 
               BlendMode_Divide(base.g, blend.g), 
               BlendMode_Divide(base.b, blend.b) );
}

float Luminance(float3 color)
{
   return dot(float3(0.299, 0.587, 0.114), color);
}

float Gaussian(float x)
{
   //const float PI = 3.1415926;
   //const float mean = 0.0;
   // stdDev
   // 1/(stdDev*sqrt(2*PI()))*exp(-0.5*pow((A7-Mean)/StdDev,2))
   
   float sd = max(0.01, stdDev);
   const float sqrtTwoPi = 2.5066282532517663;
    
   float temp = x / sd;
   return (1.0 / (sd * sqrtTwoPi)) * exp(-0.5 * temp * temp);
}


float4 mainImage(VertData v_in) : TARGET
{
   // Normalize Zoom
   float zoom01 = (zoom + 1.0) * 0.5;
   
   // Crop UV
   float2 uvSize = float2(1.0 - cropRight - cropLeft, 1.0 - cropBottom - cropTop) / float2(iResolution.y / iResolution.x, 1.0);
   float2 offset = float2(offsetX, offsetY);
   float2 uvOffset = float2(cropLeft, cropTop) + offset;
   float2 uv = (v_in.uv * uvSize) + uvOffset;
   float2 uvCenter = (0.5 * uvSize) + uvOffset;
   float2 uvShifted = uv - uvCenter + (zoom01 * offset);
   
   // Rotate UV
   float rotationRad = radians(rotation);
   float sinRotation = sin(rotationRad);
   float cosRotation = cos(rotationRad);
   float2 row1 = float2(cosRotation, -sinRotation);
   float2 row2 = float2(sinRotation, cosRotation);
   float2 rotatedCenter = float2(dot(row1, uvShifted), dot(row2, uvShifted));
   float2 rotatedOffset = float2(dot(row1, offset), dot(row2, offset));
   
   float2 aspectRatio = float2(iResolution.y / iResolution.x, 1.0);
   float2 rotatedUV = ((zoom01 * rotatedCenter) + uvCenter + rotatedOffset) * aspectRatio;
   
   float4 color = image.Sample(textureSampler, rotatedUV);
   
   float2 stepUV = stepRadius * float2(1.0 - cropRight - cropLeft, 1.0 - cropBottom - cropTop) / iResolution.xy;
   
   float2 leftUV  = rotatedUV + (stepUV * float2(-1,  0));
   float2 rightUV = rotatedUV + (stepUV * float2( 1,  0));
   float2 upUV    = rotatedUV + (stepUV * float2( 0,  1));
   float2 downUV  = rotatedUV + (stepUV * float2( 0, -1));
   
   float2 urUV = rotatedUV + (stepUV * float2( 1,  1));
   float2 lrUV = rotatedUV + (stepUV * float2( 1, -1));
   float2 llUV = rotatedUV + (stepUV * float2(-1, -1));
   float2 ulUV = rotatedUV + (stepUV * float2(-1,  1));
   
   // Get orthogonal samples.
   float4 colorLt = image.Sample(textureSampler, leftUV);
   float4 colorRt = image.Sample(textureSampler, rightUV);
   float4 colorUp = image.Sample(textureSampler, upUV);
   float4 colorDn = image.Sample(textureSampler, downUV);

   // Get diagogonal samples.
   float4 colorUR = image.Sample(textureSampler, urUV);
   float4 colorLR = image.Sample(textureSampler, lrUV);
   float4 colorLL = image.Sample(textureSampler, llUV);
   float4 colorUL = image.Sample(textureSampler, ulUV);
   
   float coefCt = Gaussian(0.0);
   float coefLRUD = Gaussian(1.0);
   float coefURLRLLUL = Gaussian(1.414);
   float normalize = coefCt + (4.0 * coefLRUD) + (4.0 * coefURLRLLUL);
   
   float4 blur = (coefCt * color) + (coefLRUD * colorLt) + (coefLRUD * colorRt) + (coefLRUD * colorUp) + (coefLRUD * colorDn);
   blur += (coefURLRLLUL * colorUR) + (coefURLRLLUL * colorLR) + (coefURLRLLUL * colorLL) + (coefURLRLLUL * colorUL);
   blur /= normalize;
   if (showBlur)
   {
      return float4(blur.rgb, 1);
   }

   float4 sobelHorz = colorUL - colorUR + (2.0 * colorLt) - (2.0 * colorRt) + colorLL - colorLR;
   float4 sobelVert = colorUL - colorLL + (2.0 * colorUp) - (2.0 * colorDn) + colorUR - colorLR;
   float4 edge = float4(pow((sobelHorz.rgb + sobelVert.rgb) * edgeScale, edgePower), 1);
   if (showEdge)
   {
      return edge;
   }
   float edgeLum01 = saturate(Luminance(edge.rgb));

   //float4 avgColor = (color + colorUR + colorLR + colorLL + colorUL + colorLt + colorRt + colorUp + colorDn) / 9.0;
   float avgLum01 = lerp(0.5, 1.0, avgLuminance);
   float4 avgColor = float4(avgLum01, avgLum01, avgLum01, 1);
   
   float sharpness01 = sharpness;
   color = lerp(blur, color, sharpness * avgLum01);
   
   float contrast13 = lerp(1.0, 3.0, contrast);
   color = lerp(avgColor, color, contrast13);
   
   //color = blur;
   
   float luminance = Luminance(color.rgb);	// update luminance with the current color
   if (!passthrough)
   {
      // Adjust color temperature.
      float3 colorTint = ColorTemperatureToRGB(colorTemperatureK);
      color.rgb = lerp(color.rgb, color.rgb * colorTint, colorTemperatureAlpha);
      //color.rgb = BlendMode_ColorDodge3(color.rgb, colorTint);    // screen
   
       // Apply mid Saturation
      float3 color2 = lerp(float3(luminance, luminance, luminance), color.rgb, midSaturationScale);
   
      // Apply mid Brightness
      color2 = midBrightnessScale * midBrightnessScale * color2.rgb;
   
      // Apply mid Gamma
      color2 = pow(color2.rgb, midGammaScale);
   
      float lowStep = smoothstep(shadowLuminance, shadowLuminance + shadowBlend, luminance);
      float highStep = 1.0 - smoothstep(highlightLuminance - highlightBlend, highlightLuminance, luminance);
   
      color2.rgb = lerp(color.rgb, color2, lowStep * highStep);
      if (showLowLuminance)
      {
        color2.rgb = lerp(color.rgb * 10.0, float3(0,0,0), lowStep);
      }
      else if (showHighLuminance)
      {
        color2.rgb = lerp(color.rgb, float3(0,0,0), highStep);
      }
      else if (showMiddleLuminance)
      {
         color2.rgb = lerp(color.rgb * 10.0, float3(0, 0, 0), lowStep);
         color2.rgb = lerp(float3(0, 0, 0), color.rgb, highStep);
      }

      // Apply final Saturation
      color2 = lerp(float3(luminance, luminance, luminance), color2.rgb, finalSaturationScale);
      
      // Apply final Brightness
      color2 = finalBrightnessScale * finalBrightnessScale * color2.rgb;
      
      // Apply final Gamma
      color2 = pow(color2.rgb, finalGammaScale);
   
      color.rgb = color2 * float3(colorRed, colorGreen, colorBlue);
   }
   
   // Debug: Add center of rotation marker.
   const float RADIUS =  0.01;
   float recipZoom = 1.0 / zoom01;
   if (showCenter && (length(rotatedCenter + rotatedOffset * recipZoom) < (RADIUS * recipZoom)))
   {
     color = float4(1,0,0,1);
   }
   
   return color;
}

